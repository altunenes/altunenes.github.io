<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Randomness: CPU & GPU
        
    </title><meta content="Randomness: CPU & GPU" property=og:title><meta content="personal blog" property=og:description><meta content="personal blog" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://altunenes.github.io/fonts.css rel=stylesheet><link href=https://altunenes.github.io/atom.xml rel=alternate title=altunenes type=application/atom+xml><link href=https://altunenes.github.io/theme/light.css rel=stylesheet><link href=https://altunenes.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://altunenes.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://altunenes.github.io/main.css media=screen rel=stylesheet><script data-cf-beacon='{"token": "37a0f981a37240aea00b781e300bc6c0"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script></head><script>// Function to set the theme
        function setTheme(theme) {
            document.documentElement.className = theme;
            localStorage.setItem('theme', theme);
        }

        // Function to get the saved theme
        function getSavedTheme() {
            return localStorage.getItem('theme') || 'light';
        }

        // Set the theme on page load
        document.addEventListener('DOMContentLoaded', (event) => {
            setTheme(getSavedTheme());
        });</script><body><div class=content><header><div class=main><a href=https://altunenes.github.io/>altunenes</a><div class=socials><a class=social href=https://twitter.com/emportent rel=me> <img alt=x src=https://altunenes.github.io/social_icons/x.svg> </a><a class=social href=https://github.com/altunenes rel=me> <img alt=github src=https://altunenes.github.io/social_icons/github.svg> </a><a href="https://scholar.google.com/citations?user=_OtEw5oAAAAJ&hl" class=social rel=me> <img alt=scholar src=https://altunenes.github.io/social_icons/googlescholar.svg> </a><a class=social href=https://www.linkedin.com/in/enes-altun-0a3076167 rel=me> <img alt=linkedin src=https://altunenes.github.io/social_icons/linkedin.svg> </a><a class=social href=https://www.instagram.com/altunanes/ rel=me> <img alt=instagram src=https://altunenes.github.io/social_icons/instagram.svg> </a><a class=social href=https://orcid.org/0000-0002-6478-6909 rel=me> <img alt=orcid src=https://altunenes.github.io/social_icons/orcid.svg> </a><a class=social href=https://www.shadertoy.com/user/altunenes rel=me> <img alt=shadertoy src=https://altunenes.github.io/social_icons/shadertoy.svg> </a><a class=social href=https://bsky.app/profile/altunenes.bsky.social rel=me> <img alt=bluesky src=https://altunenes.github.io/social_icons/bluesky.svg> </a></div></div><nav><a href=https://altunenes.github.io/posts style=margin-left:.7em>/posts</a><a href=https://altunenes.github.io/projects style=margin-left:.7em>/projects</a><a href=https://altunenes.github.io/about style=margin-left:.7em>/about</a><a href=https://altunenes.github.io/tags style=margin-left:.7em>/tags</a><a href=https://altunenes.github.io/CV style=margin-left:.7em>/CV</a><button aria-label="Toggle dark mode" id=dark-mode-toggle onclick=toggleTheme();><img alt="Light mode" id=sun-icon src=https://altunenes.github.io/feather/sun.svg> <img alt="Dark mode" id=moon-icon src=https://altunenes.github.io/feather/moon.svg></button></nav></header><script>function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.classList.contains('dark') ? 'dark' : 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    html.classList.remove(currentTheme);
    html.classList.add(newTheme);
    
    localStorage.setItem('theme', newTheme);
    updateThemeToggleIcons();
}

function updateThemeToggleIcons() {
    const sunIcon = document.getElementById('sun-icon');
    const moonIcon = document.getElementById('moon-icon');
    const isDarkMode = document.documentElement.classList.contains('dark');
    
    sunIcon.style.display = isDarkMode ? 'none' : 'inline';
    moonIcon.style.display = isDarkMode ? 'inline' : 'none';
}

// Set initial theme
const savedTheme = localStorage.getItem('theme') || 'light';
document.documentElement.classList.add(savedTheme);
updateThemeToggleIcons();</script><main><article><div class=title><div class=page-header>Randomness: CPU & GPU<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-08-09</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://altunenes.github.io/posts/random/#background> Background </a><li><a href=https://altunenes.github.io/posts/random/#the-real-world-bottleneck>The Real-World Bottleneck</a><li><a href=https://altunenes.github.io/posts/random/#references> References </a></ul><section class=body><h4 id=background><span style=color:orange> Background </span></h4><p>Traditional random number generation, common on CPUs in languages, often relies on a sequential process. A generator object holds an internal state, and each request for a number updates that state for the next call. This approach is fundamentally incompatible with the massively parallel nature of GPUs, where thousands of threads need to generate numbers independently and simultaneously. If all threads tried to access and update a single shared state, it would require complex synchronization that would effectively destroy the GPU's performance advantage.<p>GPUs "solve" this by adopting a "stateless" or functional approach. Instead of updating a state, each thread computes its random number directly by calling a function that scrambles its inputs. In GLSL shaders, a common technique is to use a hash function that takes a thread's unique coordinates (<code>gl_FragCoord.xy</code>) and often the current time (<code>iTime</code>: in shadertoy) as input. This ensures every pixel gets a different, independent number on every frame. A simple, widely-used hash function looks like this:<pre class=language-glsl data-lang=glsl style=color:#bfbab0;background-color:#0f1419><code class=language-glsl data-lang=glsl><span style=color:#5c6773;font-style:italic>// A simple hash function that turns a 2D vector into a pseudo-random float.
</span><span style=color:#5c6773;font-style:italic>// Adding a time input makes it dynamic for animations.
</span><span style=color:#f73>float </span><span style=color:#ffb454>hash</span><span>(</span><span style=color:#f73>vec2 </span><span style=color:#f29718>p</span><span style=color:#bfbab0cc>, </span><span style=color:#f73>float </span><span style=color:#f29718>t</span><span>) {
</span><span>    </span><span style=color:#f73>vec2</span><span> p_with_time </span><span style=color:#f29668>=</span><span> p </span><span style=color:#f29668>+ </span><span style=color:#f73>vec2</span><span>(t)</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>return </span><span style=color:#f07178>fract</span><span>(</span><span style=color:#f07178>sin</span><span>(</span><span style=color:#f07178>dot</span><span>(p_with_time</span><span style=color:#bfbab0cc>, </span><span style=color:#f73>vec2</span><span>(</span><span style=color:#f29718>12.9898</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>78.233</span><span>))) </span><span style=color:#f29668>* </span><span style=color:#f29718>43758.5453</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>// You would call it in your main shader code like this:
</span><span style=color:#5c6773;font-style:italic>// (iTime is a standard uniform in environments like Shadertoy)
</span><span style=color:#f73>float</span><span> randomValue </span><span style=color:#f29668>= </span><span style=color:#ffb454>hash</span><span>(</span><span style=color:#39bae6;font-style:italic>gl_FragCoord</span><span style=color:#f29668>.</span><span>xy</span><span style=color:#bfbab0cc>,</span><span> iTime)</span><span style=color:#bfbab0cc>;
</span></code></pre><h4 id=the-real-world-bottleneck><span style=color:orange>The Real-World Bottleneck</span></h4><p>This functional paradigm is a prime example of co-designing an algorithm for its hardware. However, the GPU is not always the faster choice. Performance studies show a clear "crossover point": for small tasks that require fewer than roughly 10,000 numbers, a modern CPU is often faster due to the overhead of launching a GPU kernel (Askar et al., 2021). For larger tasks where the GPU's throughput dominates, a second, more surprising bottleneck emerges: data transfer. If the numbers are generated on the GPU but needed by the CPU, the transfer itself can cripple performance. One analysis found that copying the results back to the CPU took, on average, seven times longer than the computation itself (Gregg & Hazelwood, 2011). This highlights a fundamental rule: the highest performance is only achieved when random numbers are both generated and consumed on the same device.<p>While a simple hash is great for visual effects, this same "stateless" principle is the foundation of high-performance libraries. They use complex, cryptographically-inspired functions to generate statistically robust and uncorrelated random streams for demanding scientific simulations, an approach detailed in the landmark paper on parallel random numbers by Salmon et al..<h4 id=references><span style=color:orange> References </span></h4><p>Askar, T., Shukirgaliyev, B., Lukac, M., & Abdikamalov, E. (2021). Evaluation of Pseudo-Random Number Generation on GPU Cards. Computation, 9(12), 142.<p>Salmon, J.K., Moraes, M.A., Dror, R.O., & Shaw, D.E. (2011). Parallel random numbers: As easy as 1, 2, 3. 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (SC), 1-12.<p>Gregg, C., & Hazelwood, K.M. (2011). Where is the data? Why you cannot debate CPU vs. GPU performance without the answer. (IEEE ISPASS) IEEE INTERNATIONAL SYMPOSIUM ON PERFORMANCE ANALYSIS OF SYSTEMS AND SOFTWARE, 134-144.</section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=https://altunenes.github.io/tags/gpu/>GPU</a><li><a href=https://altunenes.github.io/tags/cpu/>CPU</a><li><a href=https://altunenes.github.io/tags/randomness/>Randomness</a><li><a href=https://altunenes.github.io/tags/shadertoy/>Shadertoy</a><li><a href=https://altunenes.github.io/tags/rust/>Rust</a></ul></nav></div><hr><div class=citation style=color:var(--text-color-secondary);margin-top:2em;font-size:.8em><p style=margin-bottom:.6em;font-size:.9em;font-weight:700>Cite:<p style=margin-bottom:.5em>Altun, E. (2025, August 09). <em>Randomness: CPU & GPU</em>. Retrieved from <a href=https://altunenes.github.io/posts/random/>https://altunenes.github.io/posts/random/</a><p><small><a href=http://creativecommons.org/licenses/by/4.0/ rel=license target=_blank>CC BY 4.0</a></small></div></article></main><div class=giscus></div><script async crossorigin data-category=General data-category-id=DIC_kwDOL5Nyoc4CfU7n data-emit-metadata=0 data-input-position=bottom data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=altunenes/altunenes.github.io data-repo-id=R_kgDOL5NyoQ data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div>