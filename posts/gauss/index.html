<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Gaussian Splats with Simple Linear Iterative Clustering
        
    </title><meta content="Gaussian Splats with Simple Linear Iterative Clustering" property=og:title><meta content="personal blog" property=og:description><meta content="personal blog" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://altunenes.github.io/fonts.css rel=stylesheet><link href=https://altunenes.github.io/atom.xml rel=alternate title=altunenes type=application/atom+xml><link href=https://altunenes.github.io/theme/light.css rel=stylesheet><link href=https://altunenes.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://altunenes.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://altunenes.github.io/main.css media=screen rel=stylesheet><script data-cf-beacon='{"token": "37a0f981a37240aea00b781e300bc6c0"}' defer src=https://static.cloudflareinsights.com/beacon.min.js></script></head><script>// Function to set the theme
        function setTheme(theme) {
            document.documentElement.className = theme;
            localStorage.setItem('theme', theme);
        }

        // Function to get the saved theme
        function getSavedTheme() {
            return localStorage.getItem('theme') || 'light';
        }

        // Set the theme on page load
        document.addEventListener('DOMContentLoaded', (event) => {
            setTheme(getSavedTheme());
        });</script><body><div class=content><header><div class=main><a href=https://altunenes.github.io/>altunenes</a><div class=socials><a class=social href=https://twitter.com/emportent rel=me> <img alt=x src=https://altunenes.github.io/social_icons/x.svg> </a><a class=social href=https://github.com/altunenes rel=me> <img alt=github src=https://altunenes.github.io/social_icons/github.svg> </a><a href="https://scholar.google.com/citations?user=_OtEw5oAAAAJ&hl" class=social rel=me> <img alt=scholar src=https://altunenes.github.io/social_icons/googlescholar.svg> </a><a class=social href=https://www.linkedin.com/in/enes-altun-0a3076167 rel=me> <img alt=linkedin src=https://altunenes.github.io/social_icons/linkedin.svg> </a><a class=social href=https://www.instagram.com/altunanes/ rel=me> <img alt=instagram src=https://altunenes.github.io/social_icons/instagram.svg> </a><a class=social href=https://orcid.org/0000-0002-6478-6909 rel=me> <img alt=orcid src=https://altunenes.github.io/social_icons/orcid.svg> </a><a class=social href=https://www.shadertoy.com/user/altunenes rel=me> <img alt=shadertoy src=https://altunenes.github.io/social_icons/shadertoy.svg> </a><a class=social href=https://bsky.app/profile/altunenes.bsky.social rel=me> <img alt=bluesky src=https://altunenes.github.io/social_icons/bluesky.svg> </a></div></div><nav><a href=https://altunenes.github.io/posts style=margin-left:.7em>/posts</a><a href=https://altunenes.github.io/projects style=margin-left:.7em>/projects</a><a href=https://altunenes.github.io/about style=margin-left:.7em>/about</a><a href=https://altunenes.github.io/tags style=margin-left:.7em>/tags</a><a href=https://altunenes.github.io/CV style=margin-left:.7em>/CV</a><button aria-label="Toggle dark mode" id=dark-mode-toggle onclick=toggleTheme();><img alt="Light mode" id=sun-icon src=https://altunenes.github.io/feather/sun.svg> <img alt="Dark mode" id=moon-icon src=https://altunenes.github.io/feather/moon.svg></button></nav></header><script>function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.classList.contains('dark') ? 'dark' : 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    html.classList.remove(currentTheme);
    html.classList.add(newTheme);
    
    localStorage.setItem('theme', newTheme);
    updateThemeToggleIcons();
}

function updateThemeToggleIcons() {
    const sunIcon = document.getElementById('sun-icon');
    const moonIcon = document.getElementById('moon-icon');
    const isDarkMode = document.documentElement.classList.contains('dark');
    
    sunIcon.style.display = isDarkMode ? 'none' : 'inline';
    moonIcon.style.display = isDarkMode ? 'inline' : 'none';
}

// Set initial theme
const savedTheme = localStorage.getItem('theme') || 'light';
document.documentElement.classList.add(savedTheme);
updateThemeToggleIcons();</script><main><article><div class=title><div class=page-header>Gaussian Splats with Simple Linear Iterative Clustering<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-04-19</time></div></div><h1>Table of Contents</h1><ul><li><a href=https://altunenes.github.io/posts/gauss/#gaussian-splats-using-superpixels> Gaussian Splats Using Superpixels</a></ul><section class=body><h4 id=gaussian-splats-using-superpixels><span style=color:orange> Gaussian Splats Using Superpixels</span></h4><p>Ever since I stumbled upon ShaderToy, I've been captivated by how some creators integrate complex imagery directly into GLSL shaders without using any external images. The concept of painting with algorithms, particularly using gaussian splats to create intricate effects, intrigued me deeply. It was a challenge I couldn't resist diving into.<p>My journey began with a desire to understand how to generate these visual elements from scratch. How could one translate a photograph into a format suitable for procedural rendering in shaders in really easy way (so I dont have to spent too much time on a single image)? The answer lay in a fusion of deep learning and traditional image processing techniques.<p>From Deep Learning to Superpixels:<p>Last year, I was reading an article about the new superpixel method called "Simple Linear Iterative Clustering" (SLIC), and the authors claim that the method is not only very accurate but its superfast. So I decided to give it a try <a href=https://www.epfl.ch/labs/ivrl/research/slic-superpixels/ rel=external>source)</a>. I started by segmenting images using a pre-trained DeepLabV3 model, a state-of-the-art tool in semantic image segmentation. This model identifies and isolates various elements of an image, providing a granular breakdown that serves as our foundation. This is really important step.<p>To enhance the texture and depth, I incorporated SLIC superpixels. And the good thing is, this method clusters pixels not just based on color but spatial proximity, creating more cohesive and visually appealing segments.<p>The final touch was alignment. Using PCA (Principal Component Analysis), I thought I could determine the orientation of each segment. By calculating the arctan2 of the principal components, I aligned our gaussian splats precisely, ensuring that each segment not only had the correct position and color but also the correct orientation.<p>And the all this process took 15 seconds in the Google-Colab, yes without GPU. Here is te output for the 512x512 Lena image:<div align=center><iframe src="https://www.shadertoy.com/embed/4cVGWt?gui=true&t=10&paused=true&muted=false" allowfullscreen frameborder=0 height=280 width=640></iframe></div><p><em>click to "play" button to see animation</em><p>Note, you can render your own outputs using the my rust backend also, it gives more performance and I included some GUI stuff:<p><a href=https://github.com/altunenes/rusty_art/blob/master/src/gaussiansplat.rs rel=external>source rust code for rendering)</a><p>here is the python code to rendering your own images:<pre class=giallo style=color:#bfbdb6;background-color:#0d1017><code data-lang=python><span class=giallo-l><span style=color:#ff8f40>import</span><span> torch</span></span>
<span class=giallo-l><span style=color:#ff8f40>import</span><span> torchvision</span><span style=color:#bfbdb6b3>.</span><span>transforms</span><span style=color:#ff8f40> as</span><span> T</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> torchvision</span><span style=color:#bfbdb6b3>.</span><span>models</span><span style=color:#bfbdb6b3>.</span><span>segmentation</span><span style=color:#ff8f40> import</span><span> deeplabv3_resnet101</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span style=color:#95e6cb> PIL</span><span style=color:#ff8f40> import</span><span> Image</span></span>
<span class=giallo-l><span style=color:#ff8f40>import</span><span> numpy</span><span style=color:#ff8f40> as</span><span> np</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> skimage</span><span style=color:#bfbdb6b3>.</span><span>segmentation</span><span style=color:#ff8f40> import</span><span> slic</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> skimage</span><span style=color:#ff8f40> import</span><span> img_as_float</span><span style=color:#bfbdb6b3>,</span><span> img_as_ubyte</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> skimage</span><span style=color:#bfbdb6b3>.</span><span>color</span><span style=color:#ff8f40> import</span><span> rgb2gray</span><span style=color:#bfbdb6b3>,</span><span> label2rgb</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> skimage</span><span style=color:#bfbdb6b3>.</span><span>filters</span><span style=color:#ff8f40> import</span><span> gaussian</span><span style=color:#bfbdb6b3>,</span><span> laplace </span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> skimage</span><span style=color:#bfbdb6b3>.</span><span>feature</span><span style=color:#ff8f40> import</span><span> canny</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> sklearn</span><span style=color:#bfbdb6b3>.</span><span>decomposition</span><span style=color:#ff8f40> import</span><span style=color:#95e6cb> PCA</span></span>
<span class=giallo-l><span style=color:#ff8f40>import</span><span> matplotlib</span><span style=color:#bfbdb6b3>.</span><span>pyplot</span><span style=color:#ff8f40> as</span><span> plt</span></span>
<span class=giallo-l><span style=color:#ff8f40>from</span><span> sklearn</span><span style=color:#bfbdb6b3>.</span><span>cluster</span><span style=color:#ff8f40> import</span><span> KMeans</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> load_model</span><span>():</span></span>
<span class=giallo-l><span>    model</span><span style=color:#f29668> =</span><span style=color:#ffb454> deeplabv3_resnet101</span><span>(pretrained</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>True</span><span>)</span></span>
<span class=giallo-l><span>    model</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>eval</span><span>()</span></span>
<span class=giallo-l><span style=color:#ff8f40>    return</span><span> model</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> process_image</span><span>(</span><span style=color:#d2a6ff>image_path</span><span>):</span></span>
<span class=giallo-l><span>    input_image</span><span style=color:#f29668> =</span><span> Image</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>open</span><span>(image_path)</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>convert</span><span>(</span><span style=color:#aad94c>'RGB'</span><span>)</span></span>
<span class=giallo-l><span>    preprocess</span><span style=color:#f29668> =</span><span> T</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>Compose</span><span>([</span></span>
<span class=giallo-l><span>        T</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>Resize</span><span>((</span><span style=color:#d2a6ff>512</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 512</span><span>))</span><span style=color:#bfbdb6b3>,</span><span style=color:#5a6673;font-style:italic> ##  you can decrease, but if you increase you have to adjust pack data fn too</span></span>
<span class=giallo-l><span>        T</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>ToTensor</span><span>()</span><span style=color:#bfbdb6b3>,</span></span>
<span class=giallo-l><span>        T</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>Normalize</span><span>(mean</span><span style=color:#f29668>=</span><span>[</span><span style=color:#d2a6ff>0.485</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0.456</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0.406</span><span>]</span><span style=color:#bfbdb6b3>,</span><span> std</span><span style=color:#f29668>=</span><span>[</span><span style=color:#d2a6ff>0.229</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0.224</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0.225</span><span>])</span></span>
<span class=giallo-l><span>    ])</span></span>
<span class=giallo-l><span>    input_tensor</span><span style=color:#f29668> =</span><span style=color:#ffb454> preprocess</span><span>(input_image)</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>unsqueeze</span><span>(</span><span style=color:#d2a6ff>0</span><span>)</span></span>
<span class=giallo-l><span style=color:#ff8f40>    return</span><span> input_tensor</span><span style=color:#bfbdb6b3>,</span><span> input_image</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> segment_image</span><span>(</span><span style=color:#d2a6ff>model</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> input_tensor</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> input_image</span><span>):</span></span>
<span class=giallo-l><span style=color:#ff8f40>    with</span><span> torch</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>no_grad</span><span>()</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span>        output</span><span style=color:#f29668> =</span><span style=color:#ffb454> model</span><span>(input_tensor)[</span><span style=color:#aad94c>'out'</span><span>][</span><span style=color:#d2a6ff>0</span><span>]</span></span>
<span class=giallo-l><span>    semantic_segmentation</span><span style=color:#f29668> =</span><span> output</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>argmax</span><span>(</span><span style=color:#d2a6ff>0</span><span>)</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>numpy</span><span>()</span></span>
<span class=giallo-l><span>    resized_input_image</span><span style=color:#f29668> =</span><span> input_image</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>resize</span><span>((semantic_segmentation</span><span style=color:#bfbdb6b3>.</span><span>shape[</span><span style=color:#d2a6ff>1</span><span>]</span><span style=color:#bfbdb6b3>,</span><span> semantic_segmentation</span><span style=color:#bfbdb6b3>.</span><span>shape[</span><span style=color:#d2a6ff>0</span><span>])</span><span style=color:#bfbdb6b3>,</span><span> Image</span><span style=color:#bfbdb6b3>.</span><span style=color:#95e6cb>LANCZOS</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    gray_image</span><span style=color:#f29668> =</span><span style=color:#ffb454> img_as_float</span><span>(</span><span style=color:#ffb454>rgb2gray</span><span>(np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>array</span><span>(resized_input_image)))</span></span>
<span class=giallo-l><span>    log_image</span><span style=color:#f29668> =</span><span style=color:#ffb454> laplace</span><span>(</span><span style=color:#ffb454>gaussian</span><span>(gray_image</span><span style=color:#bfbdb6b3>,</span><span> sigma</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>1</span><span>))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    log_image</span><span style=color:#f29668> =</span><span> (log_image</span><span style=color:#f29668> -</span><span> log_image</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>min</span><span>())</span><span style=color:#f29668> /</span><span> (log_image</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>max</span><span>()</span><span style=color:#f29668> -</span><span> log_image</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>min</span><span>())</span></span>
<span class=giallo-l><span>    edge_enhanced_image</span><span style=color:#f29668> =</span><span style=color:#ffb454> img_as_ubyte</span><span>(np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>clip</span><span>(gray_image</span><span style=color:#f29668> +</span><span> log_image</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 1</span><span>))</span></span>
<span class=giallo-l><span style=color:#5a6673;font-style:italic>    # Apply SLIC with refined parameters. If you increase compactness, the output will be more "compact" more "circular", so I suggest decrease it as much as possible for the nice "brush" effect for gaussian splats</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    slic_segments</span><span style=color:#f29668> =</span><span style=color:#ffb454> slic</span><span>(edge_enhanced_image</span><span style=color:#bfbdb6b3>,</span><span> n_segments</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>800</span><span style=color:#bfbdb6b3>,</span><span> compactness</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>30</span><span style=color:#bfbdb6b3>,</span><span> sigma</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>1</span><span>) </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    image_array</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>array</span><span>(resized_input_image)</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>reshape</span><span>((</span><span style=color:#f29668>-</span><span style=color:#d2a6ff>1</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 3</span><span>))</span></span>
<span class=giallo-l><span>    n_clusters</span><span style=color:#f29668> =</span><span style=color:#f07178> min</span><span>(</span><span style=color:#d2a6ff>30</span><span style=color:#bfbdb6b3>,</span><span style=color:#f07178> len</span><span>(np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>unique</span><span>(slic_segments))</span><span style=color:#f29668> //</span><span style=color:#d2a6ff> 10</span><span>)</span></span>
<span class=giallo-l><span>    kmeans</span><span style=color:#f29668> =</span><span style=color:#ffb454> KMeans</span><span>(n_clusters</span><span style=color:#f29668>=</span><span>n_clusters)</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>fit</span><span>(image_array)</span></span>
<span class=giallo-l><span>    quantized_colors</span><span style=color:#f29668> =</span><span> kmeans</span><span style=color:#bfbdb6b3>.</span><span>cluster_centers_[kmeans</span><span style=color:#bfbdb6b3>.</span><span>labels_]</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>reshape</span><span>(resized_input_image</span><span style=color:#bfbdb6b3>.</span><span>size[</span><span style=color:#bfbdb6b3>::</span><span style=color:#f29668>-</span><span style=color:#d2a6ff>1</span><span>]</span><span style=color:#f29668> +</span><span> (</span><span style=color:#d2a6ff>3</span><span style=color:#bfbdb6b3>,</span><span>))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    combined_segments</span><span style=color:#f29668> =</span><span style=color:#ffb454> slic</span><span>(quantized_colors</span><span style=color:#bfbdb6b3>,</span><span> n_segments</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>800</span><span style=color:#bfbdb6b3>,</span><span> compactness</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>30</span><span style=color:#bfbdb6b3>,</span><span> sigma</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>1</span><span>)</span></span>
<span class=giallo-l><span style=color:#ff8f40>    return</span><span> combined_segments</span><span style=color:#bfbdb6b3>,</span><span> resized_input_image</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> visualize_segmentation</span><span>(</span><span style=color:#d2a6ff>segmentation</span><span>):</span></span>
<span class=giallo-l><span>    plt</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>figure</span><span>(figsize</span><span style=color:#f29668>=</span><span>(</span><span style=color:#d2a6ff>10</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 5</span><span>))</span></span>
<span class=giallo-l><span>    plt</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>imshow</span><span>(</span><span style=color:#ffb454>label2rgb</span><span>(segmentation</span><span style=color:#bfbdb6b3>,</span><span> bg_label</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>0</span><span>)</span><span style=color:#bfbdb6b3>,</span><span> interpolation</span><span style=color:#f29668>=</span><span style=color:#aad94c>'nearest'</span><span>)</span></span>
<span class=giallo-l><span>    plt</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>colorbar</span><span>()</span></span>
<span class=giallo-l><span>    plt</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>title</span><span>(</span><span style=color:#aad94c>"Segmentation Output"</span><span>)</span></span>
<span class=giallo-l><span>    plt</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>show</span><span>()</span></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> pack_data</span><span>(</span><span style=color:#d2a6ff>x</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> y</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> w</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> h</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> a</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> r</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> g</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> b</span><span>):</span><span style=color:#5a6673;font-style:italic> ##if you change image size (on torchvision pipeline), you need to change this function too</span></span>
<span class=giallo-l><span>    x</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(x</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 511</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 9 bits </span></span>
<span class=giallo-l><span>    y</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(y</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 511</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 9 bits</span></span>
<span class=giallo-l><span>    w</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(w</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l><span>    h</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(h</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l><span>    a</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(a</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l><span>    r</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(r</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l><span>    g</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(g</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l><span>    b</span><span style=color:#f29668> =</span><span style=color:#ffb454> clamp</span><span>(b</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 255</span><span>)</span><span style=color:#5a6673;font-style:italic>  # 8 bits</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    xy</span><span style=color:#f29668> =</span><span> (x</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 23</span><span>)</span><span style=color:#f29668> |</span><span> (y</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 14</span><span>)</span></span>
<span class=giallo-l><span>    whag</span><span style=color:#f29668> =</span><span> (w</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 24</span><span>)</span><span style=color:#f29668> |</span><span> (h</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 16</span><span>)</span><span style=color:#f29668> |</span><span> (a</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 8</span><span>)</span><span style=color:#f29668> |</span><span> g</span></span>
<span class=giallo-l><span>    rgb</span><span style=color:#f29668> =</span><span> (r</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 16</span><span>)</span><span style=color:#f29668> |</span><span> g</span><span style=color:#f29668> |</span><span> (b</span><span style=color:#f29668> &lt;&lt;</span><span style=color:#d2a6ff> 8</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>    return</span><span> (xy</span><span style=color:#bfbdb6b3>,</span><span> whag</span><span style=color:#bfbdb6b3>,</span><span> rgb)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> clamp</span><span>(</span><span style=color:#d2a6ff>value</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> max_value</span><span>):</span></span>
<span class=giallo-l><span style=color:#ff8f40>    return</span><span style=color:#39bae6> int</span><span>(</span><span style=color:#f07178>max</span><span>(</span><span style=color:#d2a6ff>0</span><span style=color:#bfbdb6b3>,</span><span style=color:#f07178> min</span><span>(value</span><span style=color:#bfbdb6b3>,</span><span> max_value)))</span></span>
<span class=giallo-l></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>def</span><span style=color:#ffb454> main</span><span>():</span></span>
<span class=giallo-l><span>    model</span><span style=color:#f29668> =</span><span style=color:#ffb454> load_model</span><span>()</span></span>
<span class=giallo-l><span>    input_tensor</span><span style=color:#bfbdb6b3>,</span><span> input_image</span><span style=color:#f29668> =</span><span style=color:#ffb454> process_image</span><span>(</span><span style=color:#aad94c>'enes.png'</span><span>)</span><span style=color:#5a6673;font-style:italic>  ## of course your image... </span></span>
<span class=giallo-l><span>    segmentation</span><span style=color:#bfbdb6b3>,</span><span> resized_input_image</span><span style=color:#f29668> =</span><span style=color:#ffb454> segment_image</span><span>(model</span><span style=color:#bfbdb6b3>,</span><span> input_tensor</span><span style=color:#bfbdb6b3>,</span><span> input_image)</span></span>
<span class=giallo-l><span style=color:#ffb454>    visualize_segmentation</span><span>(segmentation)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    resized_image</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>array</span><span>(resized_input_image)</span></span>
<span class=giallo-l><span>    unique_segments</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>unique</span><span>(segmentation)</span></span>
<span class=giallo-l><span>    data</span><span style=color:#f29668> =</span><span> []</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>    for</span><span> seg_id</span><span style=color:#ff8f40> in</span><span> unique_segments</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span>        mask</span><span style=color:#f29668> =</span><span> segmentation</span><span style=color:#f29668> ==</span><span> seg_id</span></span>
<span class=giallo-l><span style=color:#ff8f40>        if</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>count_nonzero</span><span>(mask)</span><span style=color:#f29668> &lt;</span><span style=color:#d2a6ff> 2</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span style=color:#ff8f40>            continue</span></span>
<span class=giallo-l><span>        segment_coords</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>argwhere</span><span>(mask)</span></span>
<span class=giallo-l><span style=color:#ff8f40>        if</span><span> segment_coords</span><span style=color:#bfbdb6b3>.</span><span>size</span><span style=color:#f29668> ==</span><span style=color:#d2a6ff> 0</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span style=color:#ff8f40>            continue</span></span>
<span class=giallo-l><span>        y</span><span style=color:#bfbdb6b3>,</span><span> x</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>mean</span><span>(segment_coords</span><span style=color:#bfbdb6b3>,</span><span> axis</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>0</span><span>)</span></span>
<span class=giallo-l><span>        h</span><span style=color:#bfbdb6b3>,</span><span> w</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>ptp</span><span>(segment_coords[</span><span style=color:#bfbdb6b3>:,</span><span style=color:#d2a6ff> 0</span><span>])</span><span style=color:#bfbdb6b3>,</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>ptp</span><span>(segment_coords[</span><span style=color:#bfbdb6b3>:,</span><span style=color:#d2a6ff> 1</span><span>])</span></span>
<span class=giallo-l><span>        color</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>mean</span><span>(resized_image[mask]</span><span style=color:#bfbdb6b3>,</span><span> axis</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>0</span><span>)</span></span>
<span class=giallo-l><span style=color:#ff8f40>        if</span><span style=color:#f07178> len</span><span>(segment_coords)</span><span style=color:#f29668> ></span><span style=color:#d2a6ff> 1</span><span style=color:#bfbdb6b3>:</span><span> </span></span>
<span class=giallo-l><span>            pca</span><span style=color:#f29668> =</span><span style=color:#ffb454> PCA</span><span>(n_components</span><span style=color:#f29668>=</span><span style=color:#d2a6ff>2</span><span>)</span></span>
<span class=giallo-l><span>            pca</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>fit</span><span>(segment_coords)</span></span>
<span class=giallo-l><span>            angle</span><span style=color:#f29668> =</span><span> np</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>arctan2</span><span>(pca</span><span style=color:#bfbdb6b3>.</span><span>components_[</span><span style=color:#d2a6ff>0</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 1</span><span>]</span><span style=color:#bfbdb6b3>,</span><span> pca</span><span style=color:#bfbdb6b3>.</span><span>components_[</span><span style=color:#d2a6ff>0</span><span style=color:#bfbdb6b3>,</span><span style=color:#d2a6ff> 0</span><span>])</span><span style=color:#f29668> *</span><span> (</span><span style=color:#d2a6ff>180</span><span style=color:#f29668> /</span><span> np</span><span style=color:#bfbdb6b3>.</span><span>pi) </span></span>
<span class=giallo-l><span style=color:#ff8f40>        else</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span>            angle</span><span style=color:#f29668> =</span><span style=color:#d2a6ff> 4</span></span>
<span class=giallo-l><span>        packed_data</span><span style=color:#f29668> =</span><span style=color:#ffb454> pack_data</span><span>(x</span><span style=color:#bfbdb6b3>,</span><span> y</span><span style=color:#bfbdb6b3>,</span><span> w</span><span style=color:#bfbdb6b3>,</span><span> h</span><span style=color:#bfbdb6b3>,</span><span> angle</span><span style=color:#bfbdb6b3>,</span><span style=color:#f29668> *</span><span>color</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>astype</span><span>(</span><span style=color:#39bae6>int</span><span>))</span></span>
<span class=giallo-l><span>        data</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>extend</span><span>(packed_data)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>    if</span><span> data</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span style=color:#f07178>        print</span><span>(</span><span style=color:#aad94c>"const uint data[] = uint[]("</span><span style=color:#bfbdb6b3>,</span><span> end</span><span style=color:#f29668>=</span><span style=color:#aad94c>''</span><span>)</span></span>
<span class=giallo-l><span style=color:#f07178>        print</span><span>(</span><span style=color:#aad94c>','</span><span style=color:#bfbdb6b3>.</span><span style=color:#ffb454>join</span><span>(</span><span style=color:#ff8f40>f</span><span style=color:#aad94c>"0x</span><span style=color:#95e6cb>{</span><span>d</span><span style=color:#ff8f40>:08x</span><span style=color:#95e6cb>}</span><span style=color:#aad94c>u"</span><span style=color:#ff8f40> for</span><span> d</span><span style=color:#ff8f40> in</span><span> data)</span><span style=color:#bfbdb6b3>,</span><span> end</span><span style=color:#f29668>=</span><span style=color:#aad94c>''</span><span>)</span></span>
<span class=giallo-l><span style=color:#f07178>        print</span><span>(</span><span style=color:#aad94c>");"</span><span>)</span></span>
<span class=giallo-l><span style=color:#f07178>        print</span><span>(</span><span style=color:#ff8f40>f</span><span style=color:#aad94c>"Total data points: </span><span style=color:#95e6cb>{</span><span style=color:#f07178>len</span><span>(data)</span><span style=color:#f29668>//</span><span style=color:#d2a6ff>3</span><span style=color:#95e6cb>}</span><span style=color:#aad94c>"</span><span>) </span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>    else</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span style=color:#f07178>        print</span><span>(</span><span style=color:#aad94c>"No data produced; consider adjusting segment size filter or model parameters."</span><span>)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span style=color:#ff8f40>if</span><span> __name__</span><span style=color:#f29668> ==</span><span style=color:#aad94c> '__main__'</span><span style=color:#bfbdb6b3>:</span></span>
<span class=giallo-l><span style=color:#ffb454>    main</span><span>()</span></span></code></pre></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=https://altunenes.github.io/tags/image/>image</a><li><a href=https://altunenes.github.io/tags/shader/>shader</a><li><a href=https://altunenes.github.io/tags/machine-learning/>Machine Learning</a><li><a href=https://altunenes.github.io/tags/pixels/>Pixels</a></ul></nav></div><hr><div class=citation style=color:var(--text-color-secondary);margin-top:2em;font-size:.8em><p style=margin-bottom:.6em;font-size:.9em;font-weight:700>Cite:<p style=margin-bottom:.5em>Altun, E. (2024, April 19). <em>Gaussian Splats with Simple Linear Iterative Clustering</em>. Retrieved from <a href=https://altunenes.github.io/posts/gauss/>https://altunenes.github.io/posts/gauss/</a><p><small><a href=http://creativecommons.org/licenses/by/4.0/ rel=license target=_blank>CC BY 4.0</a></small></div></article></main><div class=giscus></div><script async crossorigin data-category=General data-category-id=DIC_kwDOL5Nyoc4CfU7n data-emit-metadata=0 data-input-position=bottom data-lang=en data-mapping=pathname data-reactions-enabled=1 data-repo=altunenes/altunenes.github.io data-repo-id=R_kgDOL5NyoQ data-strict=0 data-theme=preferred_color_scheme src=https://giscus.app/client.js></script></div>